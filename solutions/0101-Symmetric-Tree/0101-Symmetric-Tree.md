#### 题目描述

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```
   1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:

```
  1
   / \
  2   2
   \   \
   3    3
```

**说明:**

如果你可以运用递归和迭代两种方法解决这个问题，会很加分。

#### 题目解析

最简单的策略是使用递归。

如果一个树的左子树与右子树镜像对称，那么这个树是对称的。

如果同时满足下面的条件，两个树互为镜像：

1. 它们的两个根结点具有相同的值。
2. 每个树的右子树都与另一个树的左子树镜像对称。

当然，题目中明显告知使用两种方法。

使用队列进行迭代，当然在js我们维护一个`nodeList`作为队列使用。

队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像。最初，队列中包含的是 `root.left` 以及 `root.right`。该算法的工作原理类似于 BFS，但存在一些关键差异。每次提取两个结点并比较它们的值。然后，将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。

**复杂度分析：**

- 时间复杂度：*O*(n)，因为我们遍历整个输入树一次，所以总的运行时间为 *O*(n)，其中 `n` 是树中结点的总数。
- 空间复杂度：递归调用的次数受树的高度限制。在最糟糕情况下，树是线性的，其高度为 *O*(n)。因此，在最糟糕的情况下，由栈上的递归调用造成的空间复杂度为 *O*(n)。 迭代方法搜索队列需要额外的空间。在最糟糕情况下，我们不得不向队列中插入 *O*(n) 个结点。因此，空间复杂度为 *O*(n)。