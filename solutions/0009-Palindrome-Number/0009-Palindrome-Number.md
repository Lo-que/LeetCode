#### 题目描述

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**示例 1:**

```
输入: 121
输出: true
```

**示例 2:**

```
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3:**

```
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```

**进阶:**

你能不将整数转为字符串来解决这个问题吗？

#### 题目解析

大多数人映入脑海的第一个想法应该是转换为字符串，毕竟进阶要求不要使用字符串(笑

首先检查字符串是否为回文会需要额外的非常量空间来创建字符串，其次，之前刚刚写过的反转整数眼巴巴等着呢。如果这个数字反转后和之前一致，这不就是回文数吗？

因为`javascript`众所周知的原因，此处就不考虑反转后整数溢出问题了。

当然，为了避免整数溢出问题的话，可以反转整数的一半。如果该数是回文数的话，后半部分反转后应与前半部分保持一致。如何判断反转位数已经到达了原始整数的一半呢？

临界值为反转整数大于或者等于原始整数，此时恰好为一半或过半，因为原始整数对10取整，反转整数对应乘10，原始整数每少一位，反转整数则加一位。

显而易见，我们并不能保证整数长度一定为偶数位，偶数位的一半很好处理，奇数位的一半不能整除2，似乎处理起来很麻烦。实际上，回文数的中间位总是与自己相等，所以可以直接将其去除。

```javascript
eg:当输入 12321 时，最后得到的整数与反转整数分别为(12, 123) 直接将反转整数的最后一位去掉即可。
```

最后，两点临界需要注意：

* 所有负数不可能是负数
* 如果数字的最后一位是0, 为了使该数字为回文，则其第一位也应为0。所以排除掉非零的10的倍数的所有整数

**复杂度分析：**

- 时间复杂度：O(log~10~$x$）， 每次迭代，会将输入除以10，因此时间复杂度为O(log~10~$x$）
- 空间复杂度：O(1)