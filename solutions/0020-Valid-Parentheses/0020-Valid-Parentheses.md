#### 题目描述

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**

```
输入: "()"
输出: true
```

**示例 2:**

```
输入: "()[]{}"
输出: true
```

**示例 3:**

```
输入: "(]"
输出: false
```

**示例 4:**

```
输入: "([)]"
输出: false
```

**示例 5:**

```
输入: "{[]}"
输出: true
```



#### 题目解析

看到题目第一反应是从左到右扫描，使用计数器匹配括号。但是这种解法针只对单独类型的括号有针对性，总不能对每一种类型分别维护一个计数器，毕竟不能保证括号的相对位置。

重新阅读一下题目，有效表达式的子表达式也应该是有效表达式。（不是每个子表达式）如下：![有效括号表达式]()

看到这种类似的递归结构，我们可以考虑维护一个栈来解决问题。

1. 初始化栈 stack。
2. 一次处理表达式的每个括号。
3. 如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它，让我们简单地转到前面的 **子表达式**。
4. 如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个 `相同类型的` 左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。
5. 如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。

**复杂度分析：**

- 时间复杂度：O($n$)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1)*O*(1) 的推入和弹出操作。
- 空间复杂度：O($n$)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 `((((((((((`。